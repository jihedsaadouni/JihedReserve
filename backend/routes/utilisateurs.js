
// Importation d'Express pour cr√©er un routeur d√©di√© aux routes d'authentification
const express = require('express');
// Cr√©ation d'un routeur pour g√©rer les endpoints d'authentification
const app = express.Router();

// Importation de la connexion √† la base de donn√©es (config/db.js)
const db = require('../config/db');
// Importation de bcrypt pour hacher et comparer les mots de passe
const bcrypt = require('bcrypt');
// Importation de jsonwebtoken pour g√©n√©rer et v√©rifier les tokens JWT
const jwt = require('jsonwebtoken');

// Charger les variables d'environnement (cela charge le contenu du fichier .env)
// Assure-toi d'avoir d√©j√† install√© et configur√© le module dotenv dans ton projet.
require('dotenv').config();
const verifierToken = require("../middlewares/verifierToken"); // Importation du middleware
const verifierRole = require("../middlewares/verifierRole");
const { schemaCreationUtilisateur, schemaModificationRole, schemaValidationId } = require('../validations/reservationValidation');




// Endpoint GET pour r√©cup√©rer les informations d'un utilisateur
app.get("/:userId", verifierToken, (req, res) => {
    const userId = req.params.userId;
    // Validation de l'ID utilisateur
    const { error } = schemaValidationId.validate({ id: userId });
    if (error) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }

    // üîç Seul un admin ou l'utilisateur lui-m√™me peut voir ces infos
    if (req.user.role !== "admin" && req.user.id_utilisateur != userId) {
        return res.status(403).json({ error: "Acc√®s refus√© : vous ne pouvez voir que vos propres informations" });
    }

    const sql = "SELECT nom, email, telephone FROM utilisateurs WHERE id_utilisateur = ?";
    db.query(sql, [userId], (err, results) => {
        if (err) {
            console.error("Erreur", err);
            return res.status(500).json({ error: "Erreur lors de la r√©cup√©ration de l'utilisateur" });
        }
        if (results.length === 0) {
            return res.status(404).json({ error: "Utilisateur non trouv√©" });
        }
        res.json(results[0]);
    });
});
// Endpoint GET pour r√©cup√©rer les informations du Dashboard d'un utilisateur
app.get("/:userId/dashboard", verifierToken, (req, res) => {
    const userId = req.params.userId;
    // Validation de l'ID utilisateur
    const { error } = schemaValidationId.validate({ id: userId });
    if (error) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }

    // Seul un admin ou l'utilisateur lui-m√™me peut voir son dashboard
    if (req.user.role !== "admin" && req.user.id_utilisateur != userId) {
        return res.status(403).json({ error: "Acc√®s refus√© : vous ne pouvez voir que votre propre dashboard" });
    }

    // R√©cup√©rer les informations du dashboard (par exemple, les r√©servations)
    const sql = `
        SELECT utilisateurs.id_utilisateur,utilisateurs.nom, utilisateurs.email, utilisateurs.telephone, 
            COUNT(reservations.id_reservation) AS total_reservations
        FROM utilisateurs
        LEFT JOIN reservations ON utilisateurs.id_utilisateur = reservations.id_utilisateur
        WHERE utilisateurs.id_utilisateur = ?
        GROUP BY utilisateurs.id_utilisateur;
    `;

    db.query(sql, [userId], (err, results) => {
        if (err) {
            console.error("Erreur", err);
            return res.status(500).json({ error: "Erreur lors de la r√©cup√©ration du dashboard" });
        }
        if (results.length === 0) {
            return res.status(404).json({ error: "Utilisateur non trouv√©" });
        }
        res.json(results[0]);  // Retourner les informations du dashboard
    });
});


// üìå Seuls les admins peuvent voir tous les utilisateurs
app.get("/", verifierToken, verifierRole("admin"), (req, res) => {
    db.query("SELECT id_utilisateur, nom, email, role FROM utilisateurs", (err, results) => {
        if (err) {
            console.error("Erreur", err);
            return res.status(500).json({ error: "Erreur serveur" });
        }
        res.json(results);
    });
})

// Endpoint GET pour r√©cup√©rer le nombre total de r√©servations d'un utilisateur
app.get("/reservations/count/:userId", verifierToken, (req, res) => {
    const userId = req.params.userId;

    // Validation de l'ID utilisateur
    const { error } = schemaValidationId.validate({ id: userId });
    if (error) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }

    // Seul un admin ou l'utilisateur lui-m√™me peut voir ce nombre
    if (req.user.role !== "admin" && req.user.id_utilisateur != userId) {
        return res.status(403).json({ error: "Acc√®s refus√© : vous ne pouvez voir que vos propres r√©servations" });
    }

    const sql = `SELECT COUNT(id_reservation) AS total_reservations
                FROM reservations
                WHERE id_utilisateur = ? AND statut != 'Annul√©e'`;

    db.query(sql, [userId], (err, results) => {
        if (err) {
            console.error("Erreur", err);
            return res.status(500).json({ error: "Erreur lors de la r√©cup√©ration du nombre de r√©servations" });
        }
        if (results.length === 0) {
            return res.status(404).json({ error: "Utilisateur non trouv√©" });
        }
        res.json({ total_reservations: results[0].total_reservations });
    });
});

// Endpoint GET : Calculer le montant d√©j√† pay√© et le montant √† payer
app.get("/montants/:id", verifierToken, (req, res) => {
    // Requ√™te pour calculer le montant total pay√© pour les r√©servations "Confirm√©e"
    const sqlMontantPaye = `
        SELECT SUM(montant) AS totalPaye
        FROM reservations
        WHERE statut = 'Confirm√©e'
        AND id_utilisateur = ?;
    `;

    // Requ√™te pour calculer le montant √† payer pour les r√©servations "En attente"
    const sqlMontantAPayer = `
        SELECT SUM(montant) AS totalAPayer
        FROM reservations
        WHERE statut = 'En attente'
        AND id_utilisateur = ?;
    `;

    const userId = req.params.id;  // R√©cup√©rer l'ID utilisateur √† partir du token (d√©pend du middleware de v√©rification)

    db.query(sqlMontantPaye, [userId], (err, resultPaye) => {
        if (err) {
            console.error("Erreur lors du calcul du montant pay√© :", err);
            return res.status(500).json({ error: "Erreur serveur" });
        }

        db.query(sqlMontantAPayer, [userId], (err, resultAPayer) => {
            if (err) {
                console.error("Erreur lors du calcul du montant √† payer :", err);
                return res.status(500).json({ error: "Erreur serveur" });
            }

            const montantDejaPaye = resultPaye[0].totalPaye || 0;  // Si aucun r√©sultat, mettre 0
            const montantAPayer = resultAPayer[0].totalAPayer || 0;  // Si aucun r√©sultat, mettre 0

            res.json({
                montant_deja_paye: montantDejaPaye,
                montant_a_payer: montantAPayer
            });
        });
    });
});



// Modifier les informations d'un utilisateur (lui-m√™me ou par un admin)
app.put("/:id", verifierToken, async (req, res) => {
    const userId = req.params.id;
    // Validation de l'ID
    const { error: idError } = schemaValidationId.validate({ id: userId });
    if (idError) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }

    // Validation des donn√©es envoy√©es dans le corps
    const { error: bodyError } = schemaCreationUtilisateur.validate(req.body);
    if (bodyError) {
        return res.status(400).json({ error: bodyError.details[0].message });
    }
    const { nom, telephone, email, mot_de_passe } = req.body;

    // V√©rifier si l'utilisateur est bien l'admin ou lui-m√™me
    if (req.user.role !== "admin" && req.user.id_utilisateur != userId) {
        return res.status(403).json({ error: "Acc√®s refus√© : Vous ne pouvez modifier que votre propre compte" });
    }

    // Mise √† jour des informations de base
    let sql = "UPDATE utilisateurs SET nom = ?, telephone = ?, email = ? WHERE id_utilisateur = ?";
    let params = [nom, telephone, email, userId];

    // Si l'utilisateur veut changer son mot de passe
    if (mot_de_passe) {
        const hashedPassword = await bcrypt.hash(mot_de_passe, 10);
        sql = "UPDATE utilisateurs SET nom = ?, telephone = ?, email = ?, mot_de_passe = ? WHERE id_utilisateur = ?";
        params = [nom, telephone, email, hashedPassword, userId];
    }

    db.query(sql, params, (err, result) => {
        if (err) {
            console.error("Erreur lors de la mise √† jour :", err);
            return res.status(500).json({ error: "Erreur lors de la mise √† jour" });
        }
        res.json({ message: "Utilisateur mis √† jour avec succ√®s" },);
    });
});
// üìå Route pour modifier le r√¥le d'un utilisateur (accessible uniquement aux admins)
app.put("/modifier-role/:id", verifierToken, verifierRole("admin"), async (req, res) => {
    const userId = req.params.id; // ID de l'utilisateur √† modifier
    // Validation de l'ID
    const { error: idError } = schemaValidationId.validate({ id: userId });
    if (idError) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }

    // Validation du r√¥le
    const { error: roleError } = schemaModificationRole.validate(req.body);
    if (roleError) {
        return res.status(400).json({ error: "R√¥le invalide." });
    }
    const { role } = req.body; // Nouveau r√¥le √† attribuer

    // üìå V√©rifier que le r√¥le fourni est valide (uniquement "utilisateur" ou "gerant")
    const rolesAutorises = ["admin", "utilisateur", "gerant"];
    if (!rolesAutorises.includes(role)) {
        return res.status(400).json({ error: "R√¥le invalide." });
    }

    try {
        // üîç V√©rifier si l'utilisateur existe
        const [rows] = await db.promise().query("SELECT * FROM utilisateurs WHERE id_utilisateur = ?", [userId]);
        if (rows.length === 0) {
            return res.status(404).json({ error: "Utilisateur non trouv√©" });
        }

        // üîÑ Mise √† jour du r√¥le en base de donn√©es
        await db.promise().query("UPDATE utilisateurs SET role = ? WHERE id_utilisateur = ?", [role, userId]);

        res.json({ message: `R√¥le de l'utilisateur modifi√© en '${role}' avec succ√®s` });
    } catch (err) {
        console.error("Erreur lors de la mise √† jour du r√¥le :", err);
        res.status(500).json({ error: "Erreur serveur lors de la modification du r√¥le" });
    }
});


// Supprimer un utilisateur (uniquement par un admin)
app.delete("/:id", verifierToken, verifierRole("admin"), async (req, res) => {
    const userId = req.params.id;
    // Validation de l'ID
    const { error } = schemaValidationId.validate({ id: userId });
    if (error) {
        return res.status(400).json({ error: "ID utilisateur invalide" });
    }
    // üîç V√©rifier si l'utilisateur existe
    const [rows] = await db.promise().query("SELECT * FROM utilisateurs WHERE id_utilisateur = ?", [userId]);
    if (rows.length === 0) {
        return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    db.query("DELETE FROM utilisateurs WHERE id_utilisateur = ?", [userId], (err, result) => {
        if (err) {
            console.error("Erreur lors de la suppression :", err);
            return res.status(500).json({ error: "Erreur lors de la suppression" });
        }
        res.json({ message: "Utilisateur supprim√© avec succ√®s" });
    });
});

// üìå GET /gerant/:gerantId/terrain-id ‚Üí retourne seulement l'id_terrain du g√©rant
app.get("/gerant/:gerantId/terrain-id", verifierToken, verifierRole("admin", "gerant"), (req, res) => {
    const gerantId = req.params.gerantId;

    const { error } = schemaValidationId.validate({ id: gerantId });
    if (error) {
        return res.status(400).json({ error: "ID g√©rant invalide." });
    }
    // üîç Seul un admin ou le gerant lui-m√™me peut voirid de terrain
    if (req.user.role !== "admin" && req.user.id_utilisateur != gerantId) {
        return res.status(403).json({ error: "Acc√®s refus√© : vous ne pouvez voir que vos propres informations" });
    }

    const sql = "SELECT id_terrain FROM terrains WHERE id_gerant = ?";
    db.query(sql, [gerantId], (err, results) => {
        if (err) {
            console.error("Erreur SQL:", err);
            return res.status(500).json({ error: "Erreur serveur" });
        }

        if (results.length === 0) {
            return res.status(404).json({ error: "Aucun terrain trouv√© pour ce g√©rant." });
        }

        res.json({ id_terrain: results[0].id_terrain });
    });
});

module.exports = app;



